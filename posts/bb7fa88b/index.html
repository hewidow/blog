<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="google-site-verification" content="TVTLJSiM4FVsnRw_VdBnphrIBwObXhtFqTLZNMy04Ws">














  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="线段树,区间合并,离散化,">










<meta name="description" content="线段树 区间合并 离散化">
<meta name="keywords" content="线段树,区间合并,离散化">
<meta property="og:type" content="article">
<meta property="og:title" content="[HDU-3642]Get The Treasury">
<meta property="og:url" content="https://hewidow.github.io/blog/posts/bb7fa88b/index.html">
<meta property="og:site_name" content="Widow&#39;s Blog">
<meta property="og:description" content="线段树 区间合并 离散化">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-12-12T14:35:16.542Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[HDU-3642]Get The Treasury">
<meta name="twitter:description" content="线段树 区间合并 离散化">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://hewidow.github.io/blog/posts/bb7fa88b/">





  <title>[HDU-3642]Get The Treasury | Widow's Blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?5c1fbb7e4902f0d279f19a1ee14026ba";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Widow's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/blog/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/blog/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hewidow.github.io/blog/blog/posts/bb7fa88b/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RDJ.Widow">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Widow's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">[HDU-3642]Get The Treasury</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-11T22:13:17+08:00">
                2018-12-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/线段树/" itemprop="url" rel="index">
                    <span itemprop="name">线段树</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/blog/posts/bb7fa88b/" class="leancloud_visitors" data-flag-title="[HDU-3642]Get The Treasury">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>线段树 区间合并 离散化<br><a id="more"></a></p>
<center><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3642" target="_blank" rel="noopener"><strong>Get The Treasury</strong></a></center><br><center>Time Limit: 10000/5000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)<br>Total Submission(s): 3758    Accepted Submission(s): 1203</center>


<p><strong>Problem Description</strong></p>
<blockquote>
<p>Jack knows that there is a great underground treasury in a secret region. And he has a special device that can be used to detect treasury under the surface of the earth. One day he got outside with the device to ascertain the treasury. He chose many different locations on the surface of the earth near the secret region. And at each spot he used the device to detect treasury and got some data from it representing a region, which may contain treasury below the surface. The data from the device at each spot is six integers x1, y1, z1, x2, y2 and z2 (x1&lt;x2, y1&lt;y2, z1&lt;z2). According to the instruction of the device they represent the range of x, y and z coordinates of the region. That is to say, the x coordinate of the region, which may contain treasury, ranges from x1 to x2. So do y and z coordinates. The origin of the coordinates is a fixed point under the ground.<br>Jack can’t get the total volume of the treasury because these regions don’t always contain treasury. Through years of experience, he discovers that if a region is detected that may have treasury at more than two different spots, the region really exist treasure. And now Jack only wants to know the minimum volume of the treasury.<br>Now Jack entrusts the problem to you.</p>
</blockquote>
<p><strong>Input</strong></p>
<blockquote>
<p>The first line of the input file contains a single integer t, the number of test cases, followed by the input data for each test case.<br>Each test case is given in some lines. In the first line there is an integer n (1 ≤ n ≤ 1000), the number of spots on the surface of the earth that he had detected. Then n lines follow, every line contains six integers x1, y1, z1, x2, y2 and z2, separated by a space. The absolute value of x and y coordinates of the vertices is no more than 106, and that of z coordinate is no more than 500.</p>
</blockquote>
<p><strong>Output</strong></p>
<blockquote>
<p>For each test case, you should output “Case a: b” in a single line. a is the case number, and b is the minimum volume of treasury. The case number is counted from one.</p>
</blockquote>
<p><strong>Sample Input</strong></p>
<blockquote>
<p>2<br>1<br>0 0 0 5 6 4<br>3<br>0 0 0 5 5 5<br>3 3 3 9 10 11<br>3 3 3 13 20 45</p>
</blockquote>
<p><strong>Sample Output</strong></p>
<blockquote>
<p>Case 1: 0<br>Case 2: 8</p>
</blockquote>
<p>因为之前没有搞博客，所以注释都写在代码里了，我这个人也比较懒，就不提取出来了，稍微改一下好了。。。</p>
<p><strong>代码</strong><br>先放一份自己的弱鸡pushdown代码（C++ TLE。。。）感觉就修改覆盖几次方便，不用像只有pushup的版本一样写一大堆tree。。。<br><strong>AC 4633ms G++</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">emmm这是一道三维求重叠至少3次的体积...</span></span><br><span class="line"><span class="comment">应该要离散化。。。</span></span><br><span class="line"><span class="comment">思路1（太麻烦）：我感觉先算重叠的x-y轴面积，然后再乘重叠z轴。。。</span></span><br><span class="line"><span class="comment">思路2(错。。难实现)：每一面都算一遍重叠面积，然后乘起来就是xy*xz*yz=x2*y2*z2,开根号就是体积xyz了。。。</span></span><br><span class="line"><span class="comment">百度思路：暴力枚举z轴，反正就500。。。</span></span><br><span class="line"><span class="comment">然后就超时啦。。。</span></span><br><span class="line"><span class="comment">memset搞小也没用。。。</span></span><br><span class="line"><span class="comment">只能离散z轴再枚举了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> fuck=<span class="number">1e6</span>;<span class="comment">//原谅我的粗暴</span></span><br><span class="line"><span class="keyword">int</span> tree[maxn&lt;&lt;<span class="number">2</span>|<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> flag[maxn&lt;&lt;<span class="number">2</span>|<span class="number">3</span>];<span class="comment">//记录标记</span></span><br><span class="line"><span class="keyword">int</span> x[maxn&lt;&lt;<span class="number">2</span>|<span class="number">3</span>];<span class="comment">//离散x轴并记录下来</span></span><br><span class="line"><span class="keyword">int</span> ak[maxn&lt;&lt;<span class="number">2</span>|<span class="number">3</span>];<span class="comment">//离散z轴并记录下来</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,h;</span><br><span class="line">    <span class="keyword">int</span> cov;</span><br><span class="line">&#125;line[maxn&lt;&lt;<span class="number">2</span>|<span class="number">3</span>];<span class="comment">//存每条边的左端点l，右端点r，和y轴坐标h，以及cov存的是上边还是下边，下边为1，上边为-1，从下往上扫描</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">&#125;sx[maxn&lt;&lt;<span class="number">2</span>|<span class="number">3</span>];<span class="comment">//记录题目提供的数据，因为下面在遍历每个z坐标时需要从题目给的数据中提取出在z坐标范围内符合的数据</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a,Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.h&lt;b.h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[rt]=tree[rt&lt;&lt;<span class="number">1</span>]+tree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];<span class="comment">//这里不用担心会pushup错，因为比如父树不混乱且已经覆盖了三层，然后需要updata他的左子树，因为有pushdown，所以右子树也是有值的，所以是可以保证一个标记不混乱的父树的所有子树都有值且有标记，所以即使不管怎么updata，pushup上来都是对的。所以这种如果查询区间，可以保证每个区间都是正确的，而下面那种updata版本就不行</span></span><br><span class="line">    <span class="keyword">if</span> (flag[rt&lt;&lt;<span class="number">1</span>]!=flag[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]) flag[rt]=<span class="number">-1</span>;<span class="comment">//如果左子树和右子树标记不一样，父树标记就记为-1，代表标记混乱，找的时候就要去找子树了</span></span><br><span class="line">    <span class="keyword">else</span> flag[rt]=flag[rt&lt;&lt;<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> m,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag[rt]!=<span class="number">-1</span>)<span class="comment">//如果标记不混乱就下推标记</span></span><br><span class="line">    &#123;</span><br><span class="line">        flag[rt&lt;&lt;<span class="number">1</span>]=flag[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=flag[rt];</span><br><span class="line">        <span class="keyword">if</span> (flag[rt]&lt;=<span class="number">2</span>)<span class="comment">/*！！！此处和其他2处可以通过修改&lt;=的值来达到任意求覆盖多少层的效果！！！*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            tree[rt&lt;&lt;<span class="number">1</span>]=tree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tree[rt&lt;&lt;<span class="number">1</span>]=x[m]-x[l<span class="number">-1</span>];<span class="comment">//因为下面主函数里是l+1，r进来的，所以这里l-1</span></span><br><span class="line">            tree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=x[r]-x[m];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> nl,<span class="keyword">int</span> nr,<span class="keyword">int</span> nc,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nl&lt;=l&amp;&amp;r&lt;=nr&amp;&amp;flag[rt]!=<span class="number">-1</span>)<span class="comment">//标记不混乱才可以进去更新。当然，不用担心当l==r时，因为l==r时标记肯定不混乱，因为l==r已经没有子树给他混乱了</span></span><br><span class="line">    &#123;</span><br><span class="line">        flag[rt]+=nc;<span class="comment">//加上标记，可以算出来覆盖了几层，flag肯定大于等于0</span></span><br><span class="line">        <span class="keyword">if</span> (flag[rt]&lt;=<span class="number">2</span>)<span class="comment">/*！！！此处和其他2处可以通过修改&lt;=的值来达到任意求覆盖多少层的效果！！！*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            tree[rt]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tree[rt]=x[r]-x[l<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    pushdown(l,r,m,rt);</span><br><span class="line">    <span class="keyword">if</span> (nl&lt;=m) updata(nl,nr,nc,l,m,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (nr&gt;m) updata(nl,nr,nc,m+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,t,cnt,real_cnt,cas=<span class="number">0</span>,cont,real_cont;</span><br><span class="line">    <span class="keyword">int</span> x1,y1,z1,x2,y2,z2;</span><br><span class="line">    <span class="comment">//int minn_z=501;</span></span><br><span class="line">    <span class="comment">//int maxn_z=-501;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        cont=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d%d"</span>,&amp;x1,&amp;y1,&amp;z1,&amp;x2,&amp;y2,&amp;z2);</span><br><span class="line">            x1+=fuck;</span><br><span class="line">            y1+=fuck;</span><br><span class="line">            x2+=fuck;</span><br><span class="line">            y2+=fuck;<span class="comment">//把负坐标变正</span></span><br><span class="line">            ak[++cont]=z1;</span><br><span class="line">            ak[++cont]=z2;<span class="comment">//离散z轴</span></span><br><span class="line">            sx[i].x=x1;</span><br><span class="line">            sx[i].y=y1;</span><br><span class="line">            sx[i].z=z1;</span><br><span class="line">            sx[i+n].x=x2;</span><br><span class="line">            sx[i+n].y=y2;</span><br><span class="line">            sx[i+n].z=z2;<span class="comment">//存数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        sort(ak+<span class="number">1</span>,ak+cont+<span class="number">1</span>);</span><br><span class="line">        real_cont=unique(ak+<span class="number">1</span>,ak+cont+<span class="number">1</span>)-ak<span class="number">-1</span>;<span class="comment">//去重</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;real_cont;k++)<span class="comment">//枚举z轴，相当于切黄瓜一样，一层一层算，而且z都是整数,这里用k防止和sx的z混淆</span></span><br><span class="line">        &#123;</span><br><span class="line">            cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (sx[i].z&lt;=ak[k]&amp;&amp;ak[k]&lt;sx[i+n].z)<span class="comment">//右边只取到&lt;号，为了排除像这种1 1 1 2 2 2 / 1 1 1 8 8 8 错算成2的情况，和下面扫描线只到倒数第二根一个道理</span></span><br><span class="line">                &#123;</span><br><span class="line">                    x[++cnt]=sx[i].x;</span><br><span class="line">                    line[cnt].l=sx[i].x;</span><br><span class="line">                    line[cnt].r=sx[i+n].x;</span><br><span class="line">                    line[cnt].h=sx[i].y;</span><br><span class="line">                    line[cnt].cov=<span class="number">1</span>;</span><br><span class="line">                    x[++cnt]=sx[i+n].x;</span><br><span class="line">                    line[cnt].l=sx[i].x;</span><br><span class="line">                    line[cnt].r=sx[i+n].x;</span><br><span class="line">                    line[cnt].h=sx[i+n].y;</span><br><span class="line">                    line[cnt].cov=<span class="number">-1</span>;<span class="comment">//符合数据的进来</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//下面语句附带剪枝效果</span></span><br><span class="line">            <span class="keyword">if</span> (cnt&lt;=<span class="number">2</span>) <span class="keyword">continue</span>;<span class="comment">/*！！！此处和其他2处可以通过修改&lt;=的值来达到任意求覆盖多少层的效果！！！*/</span></span><br><span class="line">            sort(x+<span class="number">1</span>,x+cnt+<span class="number">1</span>);</span><br><span class="line">            real_cnt=unique(x+<span class="number">1</span>,x+cnt+<span class="number">1</span>)-x<span class="number">-1</span>;</span><br><span class="line">            sort(line+<span class="number">1</span>,line+cnt+<span class="number">1</span>,cmp);</span><br><span class="line">            <span class="built_in">memset</span>(flag,<span class="number">0</span>,(cnt&lt;&lt;<span class="number">2</span>|<span class="number">3</span>)*<span class="keyword">sizeof</span>(flag[<span class="number">0</span>]));</span><br><span class="line">            <span class="built_in">memset</span>(tree,<span class="number">0</span>,(cnt&lt;&lt;<span class="number">2</span>|<span class="number">3</span>)*<span class="keyword">sizeof</span>(tree[<span class="number">0</span>]));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;cnt;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> l=lower_bound(x+<span class="number">1</span>,x+real_cnt+<span class="number">1</span>,line[i].l)-x;</span><br><span class="line">                <span class="keyword">int</span> r=lower_bound(x+<span class="number">1</span>,x+real_cnt+<span class="number">1</span>,line[i].r)-x;</span><br><span class="line">                updata(l+<span class="number">1</span>,r,line[i].cov,<span class="number">1</span>,real_cnt,<span class="number">1</span>);</span><br><span class="line">                ans+=<span class="number">1l</span>l*tree[<span class="number">1</span>]*(line[i+<span class="number">1</span>].h-line[i].h)*(ak[k+<span class="number">1</span>]-ak[k]);<span class="comment">//乘上这个，因为如果z轴是一个是2一个是4，那3肯定是连续体积的，2~4不会是不连续的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %lld\n"</span>,++cas,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二份只有pushup版的代码。感谢wxk博客帮助我理解下面wxk天下第一，推一波wxk的博客<a href="https://www.cnblogs.com/MingSD/" target="_blank" rel="noopener">MingSD</a><br><strong>AC 1045ms G++</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">加个这个(l==r)?0:感觉保险一点，防止rt&lt;&lt;1和rt&lt;&lt;1|1溢出。。。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> fuck=<span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">int</span> tree[maxn&lt;&lt;<span class="number">2</span>|<span class="number">3</span>],tree2[maxn&lt;&lt;<span class="number">2</span>|<span class="number">3</span>],tree3[maxn&lt;&lt;<span class="number">2</span>|<span class="number">3</span>];<span class="comment">//tree表示覆盖1次的（即没有覆盖的）、tree2表示覆盖2次的，tree3表示覆盖3次及以上的</span></span><br><span class="line"><span class="keyword">int</span> flag[maxn&lt;&lt;<span class="number">2</span>|<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> x[maxn&lt;&lt;<span class="number">2</span>|<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> ak[maxn&lt;&lt;<span class="number">2</span>|<span class="number">3</span>];</span><br><span class="line"><span class="comment">//int cz[fuck*2+3];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,h;</span><br><span class="line">    <span class="keyword">int</span> cov;</span><br><span class="line">    Node()&#123;&#125;;</span><br><span class="line">    Node(<span class="keyword">int</span> x1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y,<span class="keyword">int</span> c)</span><br><span class="line">    &#123;</span><br><span class="line">        l=x1;</span><br><span class="line">        r=x2;</span><br><span class="line">        h=y;</span><br><span class="line">        cov=c;</span><br><span class="line">    &#125;<span class="comment">//写上这个就可以愉快地使用形如line[cnt]=Node(sx[i].x,sx[i+n].x,sx[i].y,1);这样的东西</span></span><br><span class="line">&#125;line[maxn&lt;&lt;<span class="number">2</span>|<span class="number">3</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">    sNode()&#123;&#125;;</span><br><span class="line">    sNode(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> z1)</span><br><span class="line">    &#123;</span><br><span class="line">        x=x1;</span><br><span class="line">        y=y1;</span><br><span class="line">        z=z1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sx[maxn&lt;&lt;<span class="number">2</span>|<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a,Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.h&lt;b.h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag[rt]&gt;=<span class="number">3</span>)<span class="comment">//因为下面是r-1，所以这里都是r+1</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree3[rt]=x[r+<span class="number">1</span>]-x[l];</span><br><span class="line">        tree[rt]=tree2[rt]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (flag[rt]==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tree3[rt]=(l==r)?<span class="number">0</span>:tree3[rt&lt;&lt;<span class="number">1</span>]+tree3[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+tree2[rt&lt;&lt;<span class="number">1</span>]+tree2[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+tree[rt&lt;&lt;<span class="number">1</span>]+tree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];<span class="comment">//该区间flag为2，因为没有下推，所以左右子树可能会有flag=1、2、3的，然后加上该区间的flag的值2，肯定会大于等于3。。。</span></span><br><span class="line">        tree2[rt]=x[r+<span class="number">1</span>]-x[l]-tree3[rt];</span><br><span class="line">        tree[rt]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (flag[rt]==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tree3[rt]=(l==r)?<span class="number">0</span>:tree3[rt&lt;&lt;<span class="number">1</span>]+tree3[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+tree2[rt&lt;&lt;<span class="number">1</span>]+tree2[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];<span class="comment">//同理只有子树flag=2、3，然后加上父亲的flag的值1才会大于等于3</span></span><br><span class="line">        tree2[rt]=(l==r)?<span class="number">0</span>:tree[rt&lt;&lt;<span class="number">1</span>]+tree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];<span class="comment">//同理子树flag=1加上父亲的flag的值1才会大于等于2</span></span><br><span class="line">        tree[rt]=x[r+<span class="number">1</span>]-x[l]-tree3[rt]-tree2[rt];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l==r) tree[rt]=tree2[rt]=tree3[rt]=<span class="number">0</span>;<span class="comment">//因为上三种情况都没有那肯定是当前没有覆盖，面积肯定是0呀，且没子树了，所以单独列出来</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree[rt]=tree[rt&lt;&lt;<span class="number">1</span>]+tree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">        tree2[rt]=tree2[rt&lt;&lt;<span class="number">1</span>]+tree2[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">        tree3[rt]=tree3[rt&lt;&lt;<span class="number">1</span>]+tree3[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> nl,<span class="keyword">int</span> nr,<span class="keyword">int</span> nc,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nl&lt;=l&amp;&amp;r&lt;=nr)</span><br><span class="line">    &#123;</span><br><span class="line">        flag[rt]+=nc;</span><br><span class="line">        pushup(l,r,rt);<span class="comment">//注意这里要写这个，比较特殊。因为子树可能可以通过父树的标记加上自己子树的标记满足题目条件</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nl&lt;=m) updata(nl,nr,nc,l,m,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (nr&gt;m) updata(nl,nr,nc,m+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    pushup(l,r,rt);<span class="comment">//不用担心有节点离父树好几层，无法加到，导致少加了一些。因为每次pushup上来可以保证某一层以上的都是正确的，然后如果需要updata更深层的，虽然最深层到那某一层的路途中可能都是错误的，但是可以保证的是，继续向上pushup上来，某一层包括自己及以上的都是正确的，所以往最坏的情况想至少可以保证tree[1],tree2[1],tree3[1]是正确的。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,t,cnt,real_cnt,cas=<span class="number">0</span>,cont,real_cont;</span><br><span class="line">    <span class="keyword">int</span> x1,y1,z1,x2,y2,z2;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        cont=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d%d"</span>,&amp;sx[i].x,&amp;sx[i].y,&amp;sx[i].z,&amp;sx[i+n].x,&amp;sx[i+n].y,&amp;sx[i+n].z);</span><br><span class="line">            sx[i].x+=fuck;</span><br><span class="line">            sx[i].y+=fuck;</span><br><span class="line">            sx[i+n].x+=fuck;</span><br><span class="line">            sx[i+n].y+=fuck;</span><br><span class="line">            ak[++cont]=sx[i].z;</span><br><span class="line">            ak[++cont]=sx[i+n].z;<span class="comment">//离散z轴</span></span><br><span class="line">        &#125;</span><br><span class="line">        sort(ak+<span class="number">1</span>,ak+cont+<span class="number">1</span>);</span><br><span class="line">        real_cont=unique(ak+<span class="number">1</span>,ak+cont+<span class="number">1</span>)-ak<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;real_cont;k++)<span class="comment">//枚举z轴，相当于切黄瓜一样，一层一层算，而且z都是整数,这里用k防止和sx的z混淆</span></span><br><span class="line">        &#123;</span><br><span class="line">            cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (sx[i].z&lt;=ak[k]&amp;&amp;ak[k]&lt;sx[i+n].z)<span class="comment">//排除像这种1 1 1 2 2 2 / 1 1 1 8 8 8 错算成2的情况</span></span><br><span class="line">                &#123;</span><br><span class="line">                    x[++cnt]=sx[i].x;</span><br><span class="line">                    line[cnt]=Node(sx[i].x,sx[i+n].x,sx[i].y,<span class="number">1</span>);</span><br><span class="line">                    x[++cnt]=sx[i+n].x;</span><br><span class="line">                    line[cnt]=Node(sx[i].x,sx[i+n].x,sx[i+n].y,<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt&lt;=<span class="number">2</span>) <span class="keyword">continue</span>;<span class="comment">//剪枝并且控制重叠次数语句</span></span><br><span class="line">            sort(x+<span class="number">1</span>,x+cnt+<span class="number">1</span>);</span><br><span class="line">            real_cnt=unique(x+<span class="number">1</span>,x+cnt+<span class="number">1</span>)-x<span class="number">-1</span>;</span><br><span class="line">            sort(line+<span class="number">1</span>,line+cnt+<span class="number">1</span>,cmp);</span><br><span class="line">            <span class="comment">/*for (int i=1;i&lt;=real_cnt;i++)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                cz[x[i]]=i;</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=(cnt&lt;&lt;<span class="number">2</span>|<span class="number">3</span>);i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">            &#123;</span><br><span class="line">                flag[i]=tree[i]=tree2[i]=tree3[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;cnt;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> l=lower_bound(x+<span class="number">1</span>,x+real_cnt+<span class="number">1</span>,line[i].l)-x;</span><br><span class="line">                <span class="keyword">int</span> r=lower_bound(x+<span class="number">1</span>,x+real_cnt+<span class="number">1</span>,line[i].r)-x;</span><br><span class="line">                updata(l,r<span class="number">-1</span>,line[i].cov,<span class="number">1</span>,real_cnt,<span class="number">1</span>);<span class="comment">//下面的-1是为了弥补比如原来(3,3)的空档，注意-1位置，和我之前的习惯不一样，虽然也可以用我那种。。。</span></span><br><span class="line">                ans+=<span class="number">1l</span>l*tree3[<span class="number">1</span>]*(line[i+<span class="number">1</span>].h-line[i].h)*(ak[k+<span class="number">1</span>]-ak[k]);<span class="comment">//乘上这个，因为如果z轴是一个是2一个是4，那3肯定是连续体积的，2~4不会是不连续的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %lld\n"</span>,++cas,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>两种版本时间区别这么大的原因（仅代表个人观点）：第一种因为保证了每个区间都是正确的，可能updata时前半部分的区间范围条件已经满足，但总是标记混乱，直到最后l==r时，这就导致了效率极其低下，因为此题不需要每个区间都正确，只需要下标为1的第一个区间即可。然后第二种就是只保证了下标为1的区间的正确性，不保证下面的正确与否，updata一到满足的区间就立马updata了，效率就快很多了。。。</p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    RDJ.Widow
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://hewidow.github.io/blog/posts/bb7fa88b/" title="[HDU-3642]Get The Treasury">https://hewidow.github.io/blog/posts/bb7fa88b/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/blog/tags/线段树/" rel="tag"># 线段树</a>
          
            <a href="/blog/tags/区间合并/" rel="tag"># 区间合并</a>
          
            <a href="/blog/tags/离散化/" rel="tag"># 离散化</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/blog/posts/1c291ca3/" rel="next" title="Hello World!">
                <i class="fa fa-chevron-left"></i> Hello World!
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/blog/posts/a1d9e15/" rel="prev" title="[HDU-1232]畅通工程">
                [HDU-1232]畅通工程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80MTYxMi8xODE1OQ=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/blog/images/avatar.gif" alt="RDJ.Widow">
            
              <p class="site-author-name" itemprop="name">RDJ.Widow</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blog/archives/">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/blog/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/blog/tags/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/hewidow" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://wpa.qq.com/msgrd?v=3&uin=844969710&site=qq&menu=yes" target="_blank" title="QQ">
                      
                        <i class="fa fa-fw fa-qq"></i>QQ</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/weixin_43272781" title="申屠志刚" target="_blank">申屠志刚</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.cnblogs.com/kaike" title="kaike" target="_blank">kaike</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.cnblogs.com/MingSD/" title="MingSD" target="_blank">MingSD</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="" title="若有侵犯相关利益，请联系我删除" target="_blank">若有侵犯相关利益，请联系我删除</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RDJ.Widow</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/blog/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/blog/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/blog/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("KGG67nO9fEAxLBkPBGCEe0qK-gzGzoHsz", "7rQbmHC3n9oT5GXMfn0G8m69");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
