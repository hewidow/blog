<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[ZSTUOJ-4448]用链表实现约瑟夫环]]></title>
    <url>%2Fblog%2Fposts%2Fc6a3c025%2F</url>
    <content type="text"><![CDATA[人生的第一个双向链表 用链表实现约瑟夫环 Time Limit: 1 Sec Memory Limit: 128 MBSubmit: 323 Solved: 164Description 你听说过约瑟夫问题吗？问题大致如下：首先n个人围成一个圈，标记为1到n号。接着，从1号开始报数（从1开始），然后2号报数，然后3号。。。当有人报到到m时，这个人就要踢出比赛，然后从被踢出的人的下一个人开始，重新报数（从1开始）。这样经过n-1次后，就只剩下了一个人，问最后剩下的那个人是几号？ Input 第1行为T，表示有T组数据；第2行到第T+1开始,每行输入n和m，n表示有几个人，m为上述的每报数m次就要踢出一个人1&lt;=n&lt;=100, 1&lt;=m&lt;=100 Output 一个数，表示最后剩下了几号 Sample Input 25 36 4 Sample Output 45 瞎几把乱写的，竟然还可以运行。。。 这个是注释版，最下面有没有注释的版本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/*日期：2019.1.3 17:46 修改版*/#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;const int mx=103;struct Node&#123; int x;//序号 Node *bef;//上一个 Node *next;//下一个&#125;;Node *create(int n)//创建&#123; Node *head=NULL,*p,*p2; int sz=sizeof(Node); for (int i=1;i&lt;=n;++i) &#123; p=(Node *)malloc(sz);//给当前这个p分配空间 p-&gt;x=i; p-&gt;next=NULL;//p的下一个是NULL，因为现在不清楚下一个是什么 if (head==NULL) &#123; p-&gt;bef=NULL;//head的上一个先暂定为NULL，因为不知道最后一个是什么 head=p;//head等于当前这个p p2=head;//p2等于head &#125; else &#123; p-&gt;bef=p2;//当前这个p指向上一个p2 p2-&gt;next=p;//上一个p2指向当前这个p p2=p;//p2等于p，接替当前的p &#125; &#125; head-&gt;bef=p;//指定head的上一个，使链表形成一个环 p-&gt;next=head;//循环出来后的当前的p的下一个指向head，与上一句共同使链表形成一个环 return head;//返回head的地址，因为是malloc出来的空间，不会因为函数的结束而消失，需手动free()&#125;Node *delt(Node *np)//删除&#123; Node *p,*p2; p=np-&gt;bef;//p等于要删除的np的上一个 p2=np-&gt;next;//p2等于要删除的np的下一个 p-&gt;next=p2;//p的下一个指向p2 p2-&gt;bef=p;//p2的上一个指向p free(np);//释放当前np的空间 return p2;//返回p2的地址，即要删除的np的下一个&#125;int main()&#123; int t,n,m; cin&gt;&gt;t; while (t--) &#123; cin&gt;&gt;n&gt;&gt;m; Node *head=NULL,*p,*p2; head=create(n);//返回head的地址，方便开头 for (int i=1;i&lt;n;++i)//n个人，(n-1)轮循环决出最后一人 &#123; int k=0;//想了想还是从0开始数比较直观，好看，从1开始数的代码太丑陋了。。。 p=head-&gt;bef; while (k&lt;m) &#123; p2=p-&gt;next;//p2等于p的下一个 p=p2;//p等于p2 k++;//我用了比较土的方法是，数数。。。 &#125; head=delt(p2);//新一轮的p等于要删除的结点的下一个 &#125; printf("%d\n",head-&gt;x); free(head);//释放head的空间 &#125;&#125; 去注释版12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/*日期：2019.1.3 17:53 修改去注释版*/#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;const int mx=103;struct Node&#123; int x; Node *bef; Node *next;&#125;;Node *create(int n)&#123; Node *head=NULL,*p,*p2; int sz=sizeof(Node); for (int i=1;i&lt;=n;++i) &#123; p=(Node *)malloc(sz); p-&gt;x=i; p-&gt;next=NULL; if (head==NULL) &#123; p-&gt;bef=NULL; head=p; p2=head; &#125; else &#123; p-&gt;bef=p2; p2-&gt;next=p; p2=p; &#125; &#125; head-&gt;bef=p; p-&gt;next=head; return head;&#125;Node *delt(Node *np)&#123; Node *p,*p2; p=np-&gt;bef; p2=np-&gt;next; p-&gt;next=p2; p2-&gt;bef=p; free(np); return p2;&#125;int main()&#123; int t,n,m; cin&gt;&gt;t; while (t--) &#123; cin&gt;&gt;n&gt;&gt;m; Node *head=NULL,*p,*p2; head=create(n); for (int i=1;i&lt;n;++i) &#123; int k=0;//想了想还是从0开始数比较直观，好看，从1开始数的代码太丑陋了。。。 p=head-&gt;bef; while (k&lt;m) &#123; p2=p-&gt;next; p=p2; k++; &#125; head=delt(p2); &#125; printf("%d\n",head-&gt;x); free(head); &#125;&#125;]]></content>
      <categories>
        <category>链表</category>
      </categories>
      <tags>
        <tag>双向链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[。。。]]></title>
    <url>%2Fblog%2Fposts%2F5cf76431%2F</url>
    <content type="text"><![CDATA[最近身体有些难受，还感冒了，顿时感觉搞acm学习算法很迷茫。。。不知道应该先系统地学一遍所有基础算法再研究每一个算法的进阶算法，还是学某一个基础算法时就直接将这个算法学到底，学到进阶为止。。。是先广度学习再深度学习，还是先深度学习，再广度学习。。。 诶。。。 加油吧，既然选择了这条路，跪着也要走完！ 对了，codeforces再也不用小号打了，本来想拿小号试试div2的，结果发现那场div2比div3还水，前三题迅速ac，第四题信心不足（还是要有信心啊！！！），就没去想过，第二天早上一起来秒解ac。。。小号竟然还加了几十分。。。]]></content>
      <categories>
        <category>我的随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[POJ-3067]Japan]]></title>
    <url>%2Fblog%2Fposts%2F8d53dee8%2F</url>
    <content type="text"><![CDATA[二维树状数组 逆序数 JapanTime Limit: 1000MS Memory Limit: 65536KTotal Submissions: 33788 Accepted: 9047 Description Japan plans to welcome the ACM ICPC World Finals and a lot of roads must be built for the venue. Japan is tall island with N cities on the East coast and M cities on the West coast (M &lt;= 1000, N &lt;= 1000). K superhighways will be build. Cities on each coast are numbered 1, 2, … from North to South. Each superhighway is straight line and connects city on the East coast with city of the West coast. The funding for the construction is guaranteed by ACM. A major portion of the sum is determined by the number of crossings between superhighways. At most two superhighways cross at one location. Write a program that calculates the number of the crossings between superhighways. Input The input file starts with T - the number of test cases. Each test case starts with three numbers – N, M, K. Each of the next K lines contains two numbers – the numbers of cities connected by the superhighway. The first one is the number of the city on the East coast and second one is the number of the city of the West coast. Output For each test case write one line on the standard output:Test case (case number): (number of crossings) Sample Input 13 4 41 42 33 23 1 Sample Output Test case 1: 5 这题以自己的思路做，在wa了几发后竟然ac了。。。刚开始wa是因为我以为2条线的端点在city点相交也算一个交点，然后一直写的是res+=query(ts[i].c,m-ts[i].d+1);百思不得其解，后来看百度都是什么求逆序数，再后来才看到一个和我一样的思路，然后他说是从x-1和y-1开始的，所以我才醒悟过来是不算city那个点的，所以应该写成res+=query(ts[i].c-1,m-ts[i].d+1-1);//m-ts[i].d+1，因为倒过来算。哦，对了，不用去管三线交于一点的情况。。————————————————————————————————————我的思路：左右（左east，右west）2侧，先按左边的大小排序，相等再按右边的，然后每条线的交点肯定和之前已经连接的线有关，然后只需去查左边的点的上面的连到右边的点的下面的条数，即穿越了几条线左边从上到下编号从1开始，右边从下到上编号从1开始。关于更新那就反过来更新。 代码 先来一个二维树状数组解法，比直接求逆序数的那种慢AC 454ms G++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/*又是一道我看不懂题意的题。。是直接求交点几个么。。不用管三条线交于一点那种情况？？思路：左右2侧，先按左边的大小排序，相等再按右边的，然后每条线的交点肯定和之前已经连接的线有关，然后只需去查左边的点的上面的连到右边的点的下面的条数，即穿越了几条线左边从上到下编号从1开始，右边从下到上编号从1开始。关于更新那就反过来更新*/#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;const int mx=1000;int n,m;struct Node&#123; int c,d;//c存east，d存west&#125;ts[mx*mx];int jz[mx+3][mx+3];//行表示n的,即east;列表示m的,即westbool cmp(Node a,Node b)&#123; if (a.c!=b.c) return a.c&lt;b.c; return a.d&gt;b.d;//这里改成小于号&lt;也没关系，虽然下面排序时，因为我m-ts[i].d+1会使小的变大，导致右边那列先排了大的数，但是没有关系，因为询问query的时候，加入左边是x这么大，右边是y这么大，但是询问是从x-1，y-1开始的，所以当x相同的时候，y从大到小还是从小到大都是没有关系的&#125;int lowbit(int x)&#123; return x&amp;(-x);&#125;void updata(int x,int y,int val)&#123; int z=y; while (x&lt;=n)//n &#123; y=z; while (y&lt;=m)//m &#123; jz[x][y]+=val; y+=lowbit(y); &#125; x+=lowbit(x); &#125;&#125;int query(int x,int y)&#123; int ans=0; int z=y; while (x&gt;0) &#123; y=z; while (y&gt;0) &#123; ans+=jz[x][y]; y-=lowbit(y); &#125; x-=lowbit(x); &#125; return ans;&#125;int main()&#123; long long res; int t,k,a,b,cas=0; scanf("%d",&amp;t); while (t--) &#123; res=0; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); memset(jz,0,sizeof(jz)); for (int i=1;i&lt;=k;i++) &#123; scanf("%d%d",&amp;ts[i].c,&amp;ts[i].d); &#125; sort(ts+1,ts+k+1,cmp); for (int i=1;i&lt;=k;i++) &#123; res+=query(ts[i].c-1,m-ts[i].d+1-1);//m-ts[i].d+1，因为倒过来算，且是从x-1，y-1开始的 updata(ts[i].c,m-ts[i].d+1,1); &#125; printf("Test case %d: %lld\n",++cas,res); &#125;&#125; 再来一个逆序数的。。。上面的代码看来是我想复杂了。。AC 391ms G++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/*逆序数求*/#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;const int mx=1000;int n,m;struct Node&#123; int c,d;&#125;ts[mx*mx+3];int nx[mx+3];bool cmp(Node a,Node b)&#123; if (a.c!=b.c) return a.c&lt;b.c; return a.d&lt;b.d;//&lt;号&#125;int lowbit(int x)&#123; return x&amp;(-x);&#125;void updata(int x,int val)&#123; while (x&lt;=m)//m &#123; nx[x]+=val; x+=lowbit(x); &#125;&#125;int query(int x)&#123; int ans=0; while (x&gt;0) &#123; ans+=nx[x]; x-=lowbit(x); &#125; return ans;&#125;int main()&#123; long long res; int t,k,a,b,cas=0; scanf("%d",&amp;t); while (t--) &#123; res=0; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); memset(nx,0,sizeof(nx)); for (int i=1;i&lt;=k;i++) &#123; scanf("%d%d",&amp;ts[i].c,&amp;ts[i].d); &#125; sort(ts+1,ts+k+1,cmp); for (int i=1;i&lt;=k;i++) &#123; updata(ts[i].d,1); res+=i-query(ts[i].d);//ts[i].d &#125; printf("Test case %d: %lld\n",++cas,res); &#125;&#125;]]></content>
      <categories>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>二维树状数组</tag>
        <tag>逆序数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ZSTUOJ-4438]曼哈顿距离]]></title>
    <url>%2Fblog%2Fposts%2F34116b35%2F</url>
    <content type="text"><![CDATA[差分标记 前缀和 4438: 曼哈顿距离 Time Limit: 1 Sec Memory Limit: 128 MBSubmit: 171 Solved: 52Description 在平面上，坐标（x1, y1）的点P1与坐标（x2, y2）的点P2的曼哈顿距离为：|x1-x2|+|y1-y2|。 现在有一个nXn (1&lt;=n&lt;=1000)的矩阵，一开始矩阵中每个元素的值都为零。 对这个矩阵进行m (1&lt;=m&lt;=100000)次操作，每次操作定义如下：(x1, y1), (x2, y2): 对于矩阵中满足x1&lt;=x&lt;=x2, y1&lt;=y&lt;=y2的所有元素(x, y)加上(x, y)与(x1, y1)的曼哈顿距离|x1-x|+|y1-y|例如，当n=5，m=2，两组操作分别为(1, 1), (4, 4)和(2, 2), (5, 5):现在想让你输出m次操作后的矩阵，但是由于本OJ输出文件不能超过1M，所以输出矩阵所有非零元素的乘积即可 （结果对1000000007取余）,没有非零项则输出0； Input 第一行两个整数n， m，分别表示正方形网格的边长和操作次数；接下来m行，每行4个整数x1 y1 x2 y2； Output 输出一个整数代表答案。 Sample Input 5 21 1 4 42 2 5 5Sample Output853543927 思路：首先要会差分标记，然后会求前缀和，这里放2个链接 https://blog.csdn.net/k_r_forever/article/details/81775899https://www.cnblogs.com/OIerShawnZhou/p/7348088.html 然后做的时候建立2个差分数组，一个记录每次要加的最小值，也就是1；一个记录要加的最大值，也就是加到多少为止，为x1+y1那么多。理由我代码里讲。 闲话：这道题可以说是被我和申屠一起玩坏了，先放几张图片看看这满满一页的提交，看看这内存占用的。。。就快爆128MB了。。。而且我们感觉占用110MB内存和116MB内存速度就是2个差别，所以要压力测试，使劲爆！（这样才会快点#手动滑稽） 代码先放一份不那么反人类的吧。。。AC 8776kb 92ms C1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;const int mod=1000000007;int cf[1003][1003];//差分数组一号，记录最小差分值int cf2[1003][1003];//差分数组二号，记录最大差分值long long ans=1;int flag=0;int main()&#123; int n,m,a,b,c,d,dif,now; scanf("%d%d",&amp;n,&amp;m); while (m--) &#123; scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d); cf[a][b]+=1; cf[c+1][d+1]+=1; cf[a][d+1]-=1; cf[c+1][b]-=1;//二维差分的标记方法，使(a,b)到(c,d)这整块上的值都+1 dif=a+b; cf2[a][b]+=dif; cf2[c+1][d+1]+=dif; cf2[a][d+1]-=dif; cf2[c+1][b]-=dif;//使(a,b)到(c,d)这整块上的值都+dif &#125; for (int i=1;i&lt;=n;i++) &#123; for (int j=1;j&lt;=n;j++) &#123;//下面这2个式子其实可以合并到下面那2个for循环里 cf[i][j]+=cf[i][j-1]+cf[i-1][j]-cf[i-1][j-1]; cf2[i][j]+=cf2[i][j-1]+cf2[i-1][j]-cf2[i-1][j-1];//差分求前缀和的公式，a[i][j]+=a[i][j-1]+a[i-1][j]-a[i-1][j-1]+cf[i][j]，这里因为a矩阵初始值都是0，而且前缀和只需最后的时候求一遍，所以这题可以直接用cf数组充当a数组来存储前缀和，就相当于cf[i][j]=cf[i][j-1]+cf[i-1][j]-cf[i-1][j-1]+cf[i][j]，即上面的式子，省了一些内存。。。 &#125; &#125; for (int i=1;i&lt;=n;i++) &#123; for (int j=1;j&lt;=n;j++) &#123; now=cf[i][j]*(i+j)-cf2[i][j];//下面将解释为什么上面的cf2是加上(x1+y1)，这里为什么是这样乘起来计算 if (now) &#123; flag=1; ans=ans*now%mod; &#125; &#125; &#125; if (flag) printf("%lld\n",ans); else printf("0\n"); return 0;&#125; 原因：看下面这图，只需看tot2和sum2。假设他的左上角的点为(a,b)，a=1，b=1，假设有一点(x,y)，x=3，y=5，注意这里的坐标都是以绝对坐标为准（即以(0,0)点为原点），那么cf[i][j]=1，cf2[i][j]=a+b=2，则cf[i][j] * (i+j) - cf2[i][j] = 1 * (3+5) - (1+1) = 6 = (x-a) + (y-b)，[x&gt;a且y&gt;b] ，分配一下就可以看出其实这个式子是会算出(x,y)离(a,b)点多远，相当于题目里的这个|x1-x|+|y1-y|。好，如果是叠了2层，一样的，那假设有2个左上角的点分别为(a1,b1)，(a2,b2)，有一点(x,y)，那就是cf[i][j] * (i+j) - cf2[i][j] = 2 *(x+y) - (a1+b1+a2+b2) = (x-a1) + (y-b1) + (x-a2) + (y-b2)，所以是一样的，没什么区别。。。很easy的道理，而且可以保证的是，如果有cf[i][j]的值那(i,j)的点一定比左上角的(a,b)点大。。。 然后下面是我的反人类代码，使用了快读fread()，原理是把数据先全读到缓冲区，然后再通过字符读取数据AC 127596kb 48ms C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;stdio.h&gt;const int mod=1000000007;int cf[1002][1002];int cf2[1002][1002];long long ans=1;int flag=0;namespace IO &#123; const int MT = 116 * 1024 * 1024;//这里是116MB char IO_BUF[MT]; int IO_PTR, IO_SZ; void begin() &#123; IO_PTR = 0; IO_SZ = fread (IO_BUF, 1, MT, stdin); &#125; template&lt;typename T&gt; inline bool scan_d (T &amp; t) &#123; while (IO_PTR &lt; IO_SZ &amp;&amp; IO_BUF[IO_PTR] != '-' &amp;&amp; (IO_BUF[IO_PTR] &lt; '0' || IO_BUF[IO_PTR] &gt; '9')) IO_PTR ++; if (IO_PTR &gt;= IO_SZ) return false; bool sgn = false; if (IO_BUF[IO_PTR] == '-') sgn = true, IO_PTR ++; for (t = 0; IO_PTR &lt; IO_SZ &amp;&amp; '0' &lt;= IO_BUF[IO_PTR] &amp;&amp; IO_BUF[IO_PTR] &lt;= '9'; IO_PTR ++) t = t * 10 + IO_BUF[IO_PTR] - '0'; if (sgn) t = -t; return true; &#125; inline bool scan_s (char s[]) &#123; while (IO_PTR &lt; IO_SZ &amp;&amp; (IO_BUF[IO_PTR] == ' ' || IO_BUF[IO_PTR] == '\n') ) IO_PTR ++; if (IO_PTR &gt;= IO_SZ) return false; int len = 0; while (IO_PTR &lt; IO_SZ &amp;&amp; IO_BUF[IO_PTR] != ' ' &amp;&amp; IO_BUF[IO_PTR] != '\n') s[len ++] = IO_BUF[IO_PTR], IO_PTR ++; s[len] = '\0'; return true; &#125; template&lt;typename T&gt; void print(T x) &#123; static char s[33], *s1; s1 = s; if (!x) *s1++ = '0'; if (x &lt; 0) putchar('-'), x = -x; while(x) *s1++ = (x % 10 + '0'), x /= 10; while(s1-- != s) putchar(*s1); &#125; template&lt;typename T&gt; void println(T x) &#123; print(x); putchar('\n'); &#125;&#125;;using namespace IO;//要写上这个int main()&#123; begin();//还有这个 int n,m,a,b,c,d,dif,now; scan_d(n); scan_d(m); while (m--) &#123; scan_d(a); scan_d(b); scan_d(c); scan_d(d); cf[a][b]+=1; cf[c+1][d+1]+=1; cf[a][d+1]-=1; cf[c+1][b]-=1; dif=a+b; cf2[a][b]+=dif; cf2[c+1][d+1]+=dif; cf2[a][d+1]-=dif; cf2[c+1][b]-=dif; &#125; for (int i=1;i&lt;=n;i++) &#123; for (int j=1;j&lt;=n;j++) &#123; cf[i][j]+=cf[i][j-1]+cf[i-1][j]-cf[i-1][j-1]; cf2[i][j]+=cf2[i][j-1]+cf2[i-1][j]-cf2[i-1][j-1]; &#125; &#125; for (int i=1;i&lt;=n;i++) &#123; for (int j=1;j&lt;=n;j++) &#123; now=cf[i][j]*(i+j)-cf2[i][j]; if (now) &#123; flag=1; ans=ans*now%mod; &#125; &#125; &#125; if (flag) print(ans); else print(0); return 0;&#125; 这里还有一份官方的另一份就不放了，x和y两个数组搞来搞去看都看不懂123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int N = 1e3 + 10;const int mod = 1e9 + 7;char fre[10] = "data1.in";char fot[20] = "data1.out";int tot[N][N];int sum[N][N];void solve()&#123; int n, m, u, l, d, r; scanf("%d%d", &amp;n, &amp;m); memset(tot, 0, sizeof tot); memset(sum, 0, sizeof sum); for(int i = 1; i &lt;= m; ++i)&#123; scanf("%d%d%d%d", &amp;u, &amp;l, &amp;d, &amp;r); sum[u][l] += (u + l); sum[u][r + 1] -= (u + l); sum[d + 1][l] -= (u + l); sum[d + 1][r + 1] += (u + l); tot[u][l] ++; tot[u][r + 1] --; tot[d + 1][l] --; tot[d + 1][r + 1] ++; &#125; for(int i = 1; i &lt;= n; ++i)&#123; for(int j = 1; j &lt;= n; ++j)&#123; sum[i][j] += sum[i][j - 1]; tot[i][j] += tot[i][j - 1]; printf("%d ",sum[i][j]); &#125; printf("\n"); &#125; for(int i = 1; i &lt;= n; ++i)&#123; for(int j = 1; j &lt;= n; ++j)&#123; sum[i][j] += sum[i - 1][j]; tot[i][j] += tot[i - 1][j];//他这里没有用二维前缀和的公式，而是一步一步求，具体过程可以看上面那张表格，我也放在文末了 &#125; &#125; LL ans = 1, now = 0; bool flag = false; for(int i = 1; i &lt;= n; ++i)&#123; for(int j = 1; j &lt;= n; ++j)&#123; now = tot[i][j] * (i + j) - sum[i][j]; //printf("%d ",now);// sum[i][j] = 0, tot[i][j] = 0; if(now) ans = ans * now % mod, flag = true; &#125; //printf("\n"); &#125; if(!flag) ans = 0; printf("%I64d\n", ans);&#125;int main()&#123; solve();// int T = 6;// for(int cas = 1; cas &lt;= T; ++cas)&#123;// fre[4] = ('0' + cas);// fot[4] = ('0' + cas);// freopen(fre, "r", stdin);// freopen(fot, "w", stdout);// solve();// &#125; return 0;&#125;/*4196834957756977419969355163913484590797953655*/ Excel是个好东西，Excel大法好！！！]]></content>
      <categories>
        <category>差分标记&amp;前缀和</category>
      </categories>
      <tags>
        <tag>差分标记</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU-1879]继续畅通工程]]></title>
    <url>%2Fblog%2Fposts%2F68b04a38%2F</url>
    <content type="text"><![CDATA[并查集 最小生成树 继续畅通工程Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 30061 Accepted Submission(s): 12621 Problem Description 省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可）。现得到城镇道路统计表，表中列出了任意两城镇间修建道路的费用，以及该道路是否已经修通的状态。现请你编写程序，计算出全省畅通需要的最低成本。 Input 测试输入包含若干测试用例。每个测试用例的第1行给出村庄数目N ( 1&lt; N &lt; 100 )；随后的 N(N-1)/2 行对应村庄间道路的成本及修建状态，每行给4个正整数，分别是两个村庄的编号（从1编号到N），此两村庄间道路的成本，以及修建状态：1表示已建，0表示未建。当N为0时输入结束。 Output 每个测试用例的输出占一行，输出全省畅通需要的最低成本。 Sample Input 31 2 1 01 3 2 02 3 4 031 2 1 01 3 2 02 3 4 131 2 1 01 3 2 12 3 4 10 Sample Output 310 思路：数据里已经连通的就用一遍unionjoin，没连通的就加进edge里。。。 代码还是kruskal算法，感觉这个最好用。。。不懂的看前几篇AC 312ms G++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;using namespace std;const int maxn=100;int pre[maxn+3];struct Node&#123; int st,to; int w;&#125;edge[maxn*(maxn-1)/2+3];bool cmp(Node a,Node b)&#123; return a.w&lt;b.w;&#125;void init(int n)&#123; for (int i=1;i&lt;=n;i++) pre[i]=i;&#125;int unionfind(int x)&#123; int r=x; while (pre[r]!=r) &#123; r=pre[r]; &#125; int i=x,j; while (pre[i]!=r) &#123; j=pre[i]; pre[i]=r; i=j; &#125; return r;&#125;int unionjoin(int x,int y)&#123; int fx=unionfind(x),fy=unionfind(y); if (fx!=fy) &#123; pre[fx]=fy; return 1; &#125; return 0;&#125;int kruskal(int n,int m)&#123; int num=n-1; int ans=0; for (int i=1;i&lt;=m;i++) &#123; if (unionjoin(edge[i].st,edge[i].to)) &#123; ans+=edge[i].w; num--; &#125; if (!num) return ans; &#125; return ans;&#125;int main()&#123; int t,n,m,a,b,c,d,cnt; while (~scanf("%d",&amp;n)&amp;&amp;n) &#123; init(n); cnt=0; m=n*(n-1)/2; for (int i=1;i&lt;=m;i++) &#123; scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d); if (d) &#123; unionjoin(a,b); &#125; else &#123; edge[++cnt].st=a; edge[cnt].to=b; edge[cnt].w=c; &#125; &#125; sort(edge+1,edge+cnt+1,cmp); int res=kruskal(n,cnt); printf("%d\n",res); &#125;&#125;]]></content>
      <categories>
        <category>并查集&amp;最小生成树</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU-1875]畅通工程再续]]></title>
    <url>%2Fblog%2Fposts%2F23422320%2F</url>
    <content type="text"><![CDATA[并查集 最小生成树 畅通工程再续Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 39434 Accepted Submission(s): 13243 Problem Description 相信大家都听说一个“百岛湖”的地方吧，百岛湖的居民生活在不同的小岛中，当他们想去其他的小岛时都要通过划小船来实现。现在政府决定大力发展百岛湖，发展首先要解决的问题当然是交通问题，政府决定实现百岛湖的全畅通！经过考察小组RPRush对百岛湖的情况充分了解后，决定在符合条件的小岛间建上桥，所谓符合条件，就是2个小岛之间的距离不能小于10米，也不能大于1000米。当然，为了节省资金，只要求实现任意2个小岛之间有路通即可。其中桥的价格为 100元/米。 Input 输入包括多组数据。输入首先包括一个整数T(T &lt;= 200)，代表有T组数据。每组数据首先是一个整数C(C &lt;= 100),代表小岛的个数，接下来是C组坐标，代表每个小岛的坐标，这些坐标都是 0 &lt;= x, y &lt;= 1000的整数。 Output 每组输入数据输出一行，代表建桥的最小花费，结果保留一位小数。如果无法实现工程以达到全部畅通，输出”oh!”. Sample Input 2210 1020 2031 12 21000 1000 Sample Output 1414.2oh! 思路：模拟构造之前的数据。通过循环算出两两点之间的距离，然后符合的放进edge中，再对edge进行之前的相同操作即可了。。。 代码kruskal算法，不懂的看前几篇AC 62ms G++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/*搞错地方了，应该是edge是n*(n-1)/2条*/#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;using namespace std;const int maxn=100;int pre[maxn+3];double ans;int flag;struct nNode&#123; int x,y;&#125;zb[maxn+3];struct Node&#123; int st,to; int w;&#125;edge[maxn*(maxn-1)/2+3];bool cmp(Node a,Node b)&#123; return a.w&lt;b.w;&#125;void init(int n)&#123; for (int i=1;i&lt;=n;i++) pre[i]=i;&#125;int unionfind(int x)&#123; int r=x; while (pre[r]!=r) &#123; r=pre[r]; &#125; int i=x,j; while (pre[i]!=r) &#123; j=pre[i]; pre[i]=r; i=j; &#125; return r;&#125;int unionjoin(int x,int y)&#123; int fx=unionfind(x),fy=unionfind(y); if (fx!=fy) &#123; pre[fx]=fy; return 1; &#125; return 0;&#125;void kruskal(int n,int m)&#123; int num=n-1; ans=0; flag=0; for (int i=1;i&lt;=m;i++) &#123; if (unionjoin(edge[i].st,edge[i].to)) &#123; ans+=sqrt(edge[i].w)*100.0; num--; &#125; if (!num) return; &#125; if (num) flag=1;&#125;int main()&#123; int t,n,m,a,b,c,cnt; scanf("%d",&amp;t); while (t--) &#123; scanf("%d",&amp;n); init(n); cnt=0; for (int i=1;i&lt;=n;i++) &#123; scanf("%d%d",&amp;zb[i].x,&amp;zb[i].y); &#125; for (int i=1;i&lt;=n;i++) &#123; for (int j=i+1;j&lt;=n;j++) &#123; int nx=zb[i].x-zb[j].x; int ny=zb[i].y-zb[j].y; int m=nx*nx+ny*ny; if (m&gt;=100&amp;&amp;m&lt;=1000000) &#123; edge[++cnt].st=i; edge[cnt].to=j; edge[cnt].w=m; &#125; &#125; &#125; sort(edge+1,edge+cnt+1,cmp); kruskal(n,cnt); if (!flag) printf("%.1f\n",ans); else printf("oh!\n"); &#125;&#125;]]></content>
      <categories>
        <category>并查集&amp;最小生成树</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU-1863]又是畅通工程]]></title>
    <url>%2Fblog%2Fposts%2F1e26a1b4%2F</url>
    <content type="text"><![CDATA[并查集 最小生成树 畅通工程Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 40333 Accepted Submission(s): 18025 Problem Description 省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可）。经过调查评估，得到的统计表中列出了有可能建设公路的若干条道路的成本。现请你编写程序，计算出全省畅通需要的最低成本。 Input 测试输入包含若干测试用例。每个测试用例的第1行给出评估的道路条数 N、村庄数目M ( &lt; 100 )；随后的 N行对应村庄间道路的成本，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间道路的成本（也是正整数）。为简单起见，村庄从1到M编号。当N为0时，全部输入结束，相应的结果不要输出。 Output 对每个测试用例，在1行里输出全省畅通需要的最低成本。若统计数据不足以保证畅通，则输出“?”。 Sample Input 3 31 2 11 3 22 3 41 32 3 20 100 Sample Output 3? 代码废话不多说，Kruskal算法，理解后自己乱写的版本，代码详解看上一篇AC 0ms G++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/*最小生成树Kruskal算法*/#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000;int pre[maxn+3];struct Node&#123; int st,to; int w;&#125;edge[maxn+3];bool cmp(Node a,Node b)&#123; return a.w&lt;b.w;&#125;void init(int n)&#123; for (int i=1;i&lt;=n;i++) pre[i]=i;&#125;int unionfind(int x)&#123; int r=x; while (pre[r]!=r) &#123; r=pre[r]; &#125; int i=x,j; while (pre[i]!=r) &#123; j=pre[i]; pre[i]=r; i=j; &#125; return r;&#125;int unionjoin(int x,int y)&#123; int fx=unionfind(x),fy=unionfind(y); if (fx!=fy) &#123; pre[fx]=fy; return 1; &#125; return 0;&#125;int kruskal(int n,int m)&#123; int num=n-1; int ans=0; for (int i=1;i&lt;=m;i++) &#123; if (unionjoin(edge[i].st,edge[i].to)) &#123; ans+=edge[i].w; num--; &#125; if (!num) &#123; break; &#125; &#125; if (num!=0) return 0; else return ans;&#125;int main()&#123; int n,m,a,b,c,res; while(~scanf("%d%d",&amp;m,&amp;n)&amp;&amp;m) &#123; init(n); for (int i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); edge[i].st=a; edge[i].to=b; edge[i].w=c; &#125; sort(edge+1,edge+m+1,cmp); res=kruskal(n,m); if (res) printf("%d\n",res); else printf("?\n"); &#125;&#125; Prim算法，理解后自己乱写的版本AC 0ms G++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117/*最小生成树Prim算法贼弱的我的写法WA1:太久没写重载，写错了*/#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=100;const int INF=0x3f3f3f3f;int pre[maxn+3];int s[maxn+3];//s是存放已连通的点的一个集合struct Node&#123; int to; int w;&#125;nedge,temp;bool operator &lt;(Node a,Node b)&#123; return a.w&gt;b.w;&#125;priority_queue&lt;Node&gt;q[maxn+3];//用优先队列存，边权小的在前面void init(int n)//初始化&#123; for (int i=1;i&lt;=maxn;i++) &#123; while (!q[i].empty()) &#123; q[i].pop(); &#125; &#125; for (int i=1;i&lt;=n;i++) pre[i]=i;&#125;int unionfind(int x)&#123; int r=x; while (pre[r]!=r) &#123; r=pre[r]; &#125; int i=x,j; while (pre[i]!=r) &#123; j=pre[i]; pre[i]=r; i=j; &#125; return r;&#125;int unionjoin(int x,int y)&#123; int fx=unionfind(x),fy=unionfind(y); if (fx!=fy) &#123; pre[fx]=fy; return 1; &#125; return 0;&#125;int prim(int n)//以点为起点，每次都枚举一遍已经连通的点连向其他点的边，若已在同棵树内就不要这条边，只要取不在同一棵树内的最短边，然后连上这个最小生成树，也就是将点加进这个最小生成树，也就是这里的s集合。&#123; int ans=0; int cnt=0; s[++cnt]=1;//先在s集合放个起点1 while (cnt&lt;n) &#123; int minn=INF; int xb=-1; for (int i=1;i&lt;=cnt;i++)//枚举每一个已在s集合的点且为一条边的起点 &#123; while (!q[s[i]].empty()) &#123; nedge=q[s[i]].top(); if (unionjoin(s[i],nedge.to))//若2个点已在同一棵树就删掉这条多余的边，不在的话就进去比较大小，得出一条最短边权的边 &#123; if (minn&gt;nedge.w) &#123; minn=nedge.w; xb=i; &#125; break; &#125; q[s[i]].pop(); &#125; &#125; if (xb==-1)//没有就代表组成不了一棵最小生成树 &#123; return 0; &#125; nedge=q[s[xb]].top(); q[s[xb]].pop(); s[++cnt]=nedge.to;//将最短的那条删掉，并将点加进s集合 ans+=nedge.w; &#125; return ans;&#125;int main()&#123; int n,m,a,b,c,res; while(~scanf("%d%d",&amp;m,&amp;n)&amp;&amp;m) &#123; init(n); for (int i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); temp.to=b; temp.w=c; q[a].push(temp); temp.to=a; q[b].push(temp);//第一遍少了这个还AC了，醉了。。。 &#125; res=prim(n); if (res) printf("%d\n",res); else printf("?\n"); &#125;&#125;]]></content>
      <categories>
        <category>并查集&amp;最小生成树</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU-1233]还是畅通工程]]></title>
    <url>%2Fblog%2Fposts%2F286893e3%2F</url>
    <content type="text"><![CDATA[并查集 最小生成树 还是畅通工程Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 61943 Accepted Submission(s): 28107 Problem Description 某省调查乡村交通状况，得到的统计表中列出了任意两村庄间的距离。省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可），并要求铺设的公路总长度为最小。请计算最小的公路总长度。 Input 测试输入包含若干测试用例。每个测试用例的第1行给出村庄数目N ( &lt; 100 )；随后的N(N-1)/2行对应村庄间的距离，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间的距离。为简单起见，村庄从1到N编号。当N为0时，输入结束，该用例不被处理。 Output 对每个测试用例，在1行里输出最小的公路总长度。 Sample Input 31 2 11 3 22 3 441 2 11 3 41 4 12 3 32 4 23 4 50 Sample Output 35 Hint Huge input, scanf is recommended. 代码没什么好说的，这是需要算加权边了的，然后Kruskal算法本质感觉就是个贪心算法。。AC 202ms G++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/*最小生成树Kruskal算法*/#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100;int pre[maxn+3];struct Node&#123; int st,to; int w;&#125;edge[maxn*(maxn-1)/2+3];bool cmp(Node a,Node b)&#123; return a.w&lt;b.w;&#125;void init(int n)&#123; for (int i=1;i&lt;=n;i++) pre[i]=i;//初始化，刚开始为自己&#125;int unionfind(int x)//查找根节点&#123; int r=x; while (pre[r]!=r) &#123; r=pre[r]; &#125; int i=x,j; while (pre[i]!=r)//路径压缩。最好直接连接根节点 &#123; j=pre[i]; pre[i]=r; i=j; &#125; return r;&#125;int unionjoin(int x,int y)//检查2个点的根节点是否是同一个，是就不需要任何操作，不是就将他们的根节点1加入根节点2&#123; int fx=unionfind(x),fy=unionfind(y); if (fx!=fy) &#123; pre[fx]=fy; return 1; &#125; return 0;&#125;int kruskal(int n,int m)//每次找边最短的，并判断是不是在同一棵树内，是就略过，不是就加进答案，生成这条边&#123; int num=n-1; int ans=0; for (int i=1;i&lt;=m;i++) &#123; if (unionjoin(edge[i].st,edge[i].to)) &#123; ans+=edge[i].w; num--; &#125; if (!num)//当有n-1条边时退出 &#123; break; &#125; &#125; return ans;&#125;int main()&#123; int n,m,a,b,c,res; while(~scanf("%d",&amp;n)&amp;&amp;n) &#123; init(n); res=0; m=n*(n-1)/2; for (int i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); edge[i].st=a; edge[i].to=b; edge[i].w=c; &#125; sort(edge+1,edge+m+1,cmp); res=kruskal(n,m); printf("%d\n",res); &#125;&#125;]]></content>
      <categories>
        <category>并查集&amp;最小生成树</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU-1232]畅通工程]]></title>
    <url>%2Fblog%2Fposts%2Fa1d9e15%2F</url>
    <content type="text"><![CDATA[并查集 畅通工程Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 72204 Accepted Submission(s): 38542 Problem Description 某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？ Input 测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。注意:两个城市之间可以有多条道路相通,也就是说3 31 21 22 1这种输入也是合法的当N为0时，输入结束，该用例不被处理。 Output 对每个测试用例，在1行里输出最少还需要建设的道路数目。 Sample Input 4 21 34 33 31 21 32 35 21 23 5999 00 Sample Output 102998 Hint Huge input, scanf is recommended. 思路：求有几个不连通的集合，答案就为不连通的集合个数减1 代码惯例，先放一份自己瞎几把乱写的代码，太麻烦AC 171ms G++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;set&gt;using namespace std;const int maxn=1000;bool mp[maxn+3][maxn+3];int xb[maxn+3];int vis[maxn+3];int num;int main()&#123; int n,m,a,b,cnt,sum,flag,ans; while (scanf("%d",&amp;n)!=EOF&amp;&amp;n) &#123; scanf("%d",&amp;m); set&lt;int&gt;s[n+3];//有自动去重功能和排序功能，可以二分查找 sum=0; cnt=0; ans=0; memset(mp,0,sizeof(mp)); memset(vis,0,sizeof(vis)); for (int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;a,&amp;b); if (a==b) continue; else &#123; flag=0; num=0; for (int k=1;k&lt;=cnt;k++) &#123; if (s[k].find(a)!=s[k].end()||s[k].find(b)!=s[k].end()) &#123; flag++; xb[++num]=k;//记录找到a,b的set下标 &#125; &#125; if (flag==1)//只与一个set连通，直接插入此set &#123; s[xb[1]].insert(a); s[xb[1]].insert(b); &#125; else if (flag==2)//有2个set相连通，且这里最多只可能是2 &#123;//合并这2个set，使后一个set到前一个set里 sum--; for (int r=2;r&lt;=num;r++)//num也最多只等于2 &#123; for (set&lt;int&gt;::iterator it=s[xb[r]].begin();it!=s[xb[r]].end();it++) &#123; s[xb[1]].insert(*it); &#125; s[xb[r]].clear(); &#125; &#125; else//没有set与a,b连通，就自己弄一个set存 &#123; sum++; s[++cnt].insert(a); s[cnt].insert(b); &#125; &#125; &#125; for (int i=1;i&lt;=cnt;i++)//遍历标记vis &#123; for (set&lt;int&gt;::iterator it=s[i].begin();it!=s[i].end();it++) &#123; vis[*it]=1; &#125; &#125; for (int i=1;i&lt;=n;i++) &#123; if (!vis[i]) ans++; &#125; printf("%d\n",ans+sum-1);//没有访问到的一共有ans这么多，然后加上sum个set集合就是不连通的集合的个数，再减1就是答案 &#125;&#125; 学了并查集后的代码。。。AC 31ms G++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*生动易懂https://blog.csdn.net/dellaserss/article/details/7724401*/#include&lt;stdio.h&gt;const int maxn=1000;int pre[maxn+3];void init()&#123; for (int i=1;i&lt;=maxn;i++) pre[i]=i;//初始化，刚开始为自己&#125;int unionfind(int x)//查找根节点&#123; int r=x; while (pre[r]!=r) &#123; r=pre[r]; &#125; int i=x,j; while (pre[i]!=r)//路径压缩。最好直接连接根节点 &#123; j=pre[i]; pre[i]=r; i=j; &#125; return r;&#125;void unionjoin(int x,int y)//检查2个点的根节点是否是同一个，是就不需要任何操作，不是就将他们的根节点1加入根节点2&#123; int fx=unionfind(x),fy=unionfind(y); if (fx!=fy) pre[fx]=fy;&#125;int main()&#123; int n,m,a,b,res; while(~scanf("%d",&amp;n)&amp;&amp;n) &#123; init(); res=0; scanf("%d",&amp;m); while (m--) &#123; scanf("%d%d",&amp;a,&amp;b); unionjoin(a,b); &#125; for (int i=1;i&lt;=n;i++)//只需查询有多少个根节点是自己的点就可以知道有多少个块 &#123; if (pre[i]==i) res++; &#125; printf("%d\n",res-1); &#125;&#125;]]></content>
      <categories>
        <category>并查集&amp;最小生成树</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU-3642]Get The Treasury]]></title>
    <url>%2Fblog%2Fposts%2Fbb7fa88b%2F</url>
    <content type="text"><![CDATA[线段树 区间合并 离散化 Get The TreasuryTime Limit: 10000/5000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 3758 Accepted Submission(s): 1203 Problem Description Jack knows that there is a great underground treasury in a secret region. And he has a special device that can be used to detect treasury under the surface of the earth. One day he got outside with the device to ascertain the treasury. He chose many different locations on the surface of the earth near the secret region. And at each spot he used the device to detect treasury and got some data from it representing a region, which may contain treasury below the surface. The data from the device at each spot is six integers x1, y1, z1, x2, y2 and z2 (x1&lt;x2, y1&lt;y2, z1&lt;z2). According to the instruction of the device they represent the range of x, y and z coordinates of the region. That is to say, the x coordinate of the region, which may contain treasury, ranges from x1 to x2. So do y and z coordinates. The origin of the coordinates is a fixed point under the ground.Jack can’t get the total volume of the treasury because these regions don’t always contain treasury. Through years of experience, he discovers that if a region is detected that may have treasury at more than two different spots, the region really exist treasure. And now Jack only wants to know the minimum volume of the treasury.Now Jack entrusts the problem to you. Input The first line of the input file contains a single integer t, the number of test cases, followed by the input data for each test case.Each test case is given in some lines. In the first line there is an integer n (1 ≤ n ≤ 1000), the number of spots on the surface of the earth that he had detected. Then n lines follow, every line contains six integers x1, y1, z1, x2, y2 and z2, separated by a space. The absolute value of x and y coordinates of the vertices is no more than 106, and that of z coordinate is no more than 500. Output For each test case, you should output “Case a: b” in a single line. a is the case number, and b is the minimum volume of treasury. The case number is counted from one. Sample Input 210 0 0 5 6 430 0 0 5 5 53 3 3 9 10 113 3 3 13 20 45 Sample Output Case 1: 0Case 2: 8 因为之前没有搞博客，所以注释都写在代码里了，我这个人也比较懒，就不提取出来了，稍微改一下好了。。。 代码先放一份自己的弱鸡pushdown代码（C++ TLE。。。）感觉就修改覆盖几次方便，不用像只有pushup的版本一样写一大堆tree。。。AC 4633ms G++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145/*emmm这是一道三维求重叠至少3次的体积...应该要离散化。。。思路1（太麻烦）：我感觉先算重叠的x-y轴面积，然后再乘重叠z轴。。。思路2(错。。难实现)：每一面都算一遍重叠面积，然后乘起来就是xy*xz*yz=x2*y2*z2,开根号就是体积xyz了。。。百度思路：暴力枚举z轴，反正就500。。。然后就超时啦。。。memset搞小也没用。。。只能离散z轴再枚举了*/#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;const int maxn=2000;const int fuck=1e6;//原谅我的粗暴int tree[maxn&lt;&lt;2|3];int flag[maxn&lt;&lt;2|3];//记录标记int x[maxn&lt;&lt;2|3];//离散x轴并记录下来int ak[maxn&lt;&lt;2|3];//离散z轴并记录下来struct Node&#123; int l,r,h; int cov;&#125;line[maxn&lt;&lt;2|3];//存每条边的左端点l，右端点r，和y轴坐标h，以及cov存的是上边还是下边，下边为1，上边为-1，从下往上扫描struct sNode&#123; int x,y,z;&#125;sx[maxn&lt;&lt;2|3];//记录题目提供的数据，因为下面在遍历每个z坐标时需要从题目给的数据中提取出在z坐标范围内符合的数据bool cmp(Node a,Node b)&#123; return a.h&lt;b.h;&#125;void pushup(int rt)&#123; tree[rt]=tree[rt&lt;&lt;1]+tree[rt&lt;&lt;1|1];//这里不用担心会pushup错，因为比如父树不混乱且已经覆盖了三层，然后需要updata他的左子树，因为有pushdown，所以右子树也是有值的，所以是可以保证一个标记不混乱的父树的所有子树都有值且有标记，所以即使不管怎么updata，pushup上来都是对的。所以这种如果查询区间，可以保证每个区间都是正确的，而下面那种updata版本就不行 if (flag[rt&lt;&lt;1]!=flag[rt&lt;&lt;1|1]) flag[rt]=-1;//如果左子树和右子树标记不一样，父树标记就记为-1，代表标记混乱，找的时候就要去找子树了 else flag[rt]=flag[rt&lt;&lt;1];&#125;void pushdown(int l,int r,int m,int rt)&#123; if (flag[rt]!=-1)//如果标记不混乱就下推标记 &#123; flag[rt&lt;&lt;1]=flag[rt&lt;&lt;1|1]=flag[rt]; if (flag[rt]&lt;=2)/*！！！此处和其他2处可以通过修改&lt;=的值来达到任意求覆盖多少层的效果！！！*/ &#123; tree[rt&lt;&lt;1]=tree[rt&lt;&lt;1|1]=0; &#125; else &#123; tree[rt&lt;&lt;1]=x[m]-x[l-1];//因为下面主函数里是l+1，r进来的，所以这里l-1 tree[rt&lt;&lt;1|1]=x[r]-x[m]; &#125; &#125;&#125;void updata(int nl,int nr,int nc,int l,int r,int rt)&#123; if (nl&lt;=l&amp;&amp;r&lt;=nr&amp;&amp;flag[rt]!=-1)//标记不混乱才可以进去更新。当然，不用担心当l==r时，因为l==r时标记肯定不混乱，因为l==r已经没有子树给他混乱了 &#123; flag[rt]+=nc;//加上标记，可以算出来覆盖了几层，flag肯定大于等于0 if (flag[rt]&lt;=2)/*！！！此处和其他2处可以通过修改&lt;=的值来达到任意求覆盖多少层的效果！！！*/ &#123; tree[rt]=0; &#125; else &#123; tree[rt]=x[r]-x[l-1]; &#125; return; &#125; int m=(l+r)&gt;&gt;1; pushdown(l,r,m,rt); if (nl&lt;=m) updata(nl,nr,nc,l,m,rt&lt;&lt;1); if (nr&gt;m) updata(nl,nr,nc,m+1,r,rt&lt;&lt;1|1); pushup(rt);&#125;int main()&#123; int n,t,cnt,real_cnt,cas=0,cont,real_cont; int x1,y1,z1,x2,y2,z2; //int minn_z=501; //int maxn_z=-501; long long ans; scanf("%d",&amp;t); while (t--) &#123; ans=0; cont=0; scanf("%d",&amp;n); for (int i=1;i&lt;=n;i++) &#123; scanf("%d%d%d%d%d%d",&amp;x1,&amp;y1,&amp;z1,&amp;x2,&amp;y2,&amp;z2); x1+=fuck; y1+=fuck; x2+=fuck; y2+=fuck;//把负坐标变正 ak[++cont]=z1; ak[++cont]=z2;//离散z轴 sx[i].x=x1; sx[i].y=y1; sx[i].z=z1; sx[i+n].x=x2; sx[i+n].y=y2; sx[i+n].z=z2;//存数据 &#125; sort(ak+1,ak+cont+1); real_cont=unique(ak+1,ak+cont+1)-ak-1;//去重 for (int k=1;k&lt;real_cont;k++)//枚举z轴，相当于切黄瓜一样，一层一层算，而且z都是整数,这里用k防止和sx的z混淆 &#123; cnt=0; for (int i=1;i&lt;=n;i++) &#123; if (sx[i].z&lt;=ak[k]&amp;&amp;ak[k]&lt;sx[i+n].z)//右边只取到&lt;号，为了排除像这种1 1 1 2 2 2 / 1 1 1 8 8 8 错算成2的情况，和下面扫描线只到倒数第二根一个道理 &#123; x[++cnt]=sx[i].x; line[cnt].l=sx[i].x; line[cnt].r=sx[i+n].x; line[cnt].h=sx[i].y; line[cnt].cov=1; x[++cnt]=sx[i+n].x; line[cnt].l=sx[i].x; line[cnt].r=sx[i+n].x; line[cnt].h=sx[i+n].y; line[cnt].cov=-1;//符合数据的进来 &#125; &#125;//下面语句附带剪枝效果 if (cnt&lt;=2) continue;/*！！！此处和其他2处可以通过修改&lt;=的值来达到任意求覆盖多少层的效果！！！*/ sort(x+1,x+cnt+1); real_cnt=unique(x+1,x+cnt+1)-x-1; sort(line+1,line+cnt+1,cmp); memset(flag,0,(cnt&lt;&lt;2|3)*sizeof(flag[0])); memset(tree,0,(cnt&lt;&lt;2|3)*sizeof(tree[0])); for (int i=1;i&lt;cnt;i++) &#123; int l=lower_bound(x+1,x+real_cnt+1,line[i].l)-x; int r=lower_bound(x+1,x+real_cnt+1,line[i].r)-x; updata(l+1,r,line[i].cov,1,real_cnt,1); ans+=1ll*tree[1]*(line[i+1].h-line[i].h)*(ak[k+1]-ak[k]);//乘上这个，因为如果z轴是一个是2一个是4，那3肯定是连续体积的，2~4不会是不连续的 &#125; &#125; printf("Case %d: %lld\n",++cas,ans); &#125;&#125; 第二份只有pushup版的代码。感谢wxk博客帮助我理解下面wxk天下第一，推一波wxk的博客MingSDAC 1045ms G++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143/*加个这个(l==r)?0:感觉保险一点，防止rt&lt;&lt;1和rt&lt;&lt;1|1溢出。。。*/#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;const int maxn=2000;const int fuck=1e6;int tree[maxn&lt;&lt;2|3],tree2[maxn&lt;&lt;2|3],tree3[maxn&lt;&lt;2|3];//tree表示覆盖1次的（即没有覆盖的）、tree2表示覆盖2次的，tree3表示覆盖3次及以上的int flag[maxn&lt;&lt;2|3];int x[maxn&lt;&lt;2|3];int ak[maxn&lt;&lt;2|3];//int cz[fuck*2+3];struct Node&#123; int l,r,h; int cov; Node()&#123;&#125;; Node(int x1,int x2,int y,int c) &#123; l=x1; r=x2; h=y; cov=c; &#125;//写上这个就可以愉快地使用形如line[cnt]=Node(sx[i].x,sx[i+n].x,sx[i].y,1);这样的东西&#125;line[maxn&lt;&lt;2|3];struct sNode&#123; int x,y,z; sNode()&#123;&#125;; sNode(int x1,int y1,int z1) &#123; x=x1; y=y1; z=z1; &#125;&#125;sx[maxn&lt;&lt;2|3];bool cmp(Node a,Node b)&#123; return a.h&lt;b.h;&#125;void pushup(int l,int r,int rt)&#123; if (flag[rt]&gt;=3)//因为下面是r-1，所以这里都是r+1 &#123; tree3[rt]=x[r+1]-x[l]; tree[rt]=tree2[rt]=0; &#125; else if (flag[rt]==2) &#123; tree3[rt]=(l==r)?0:tree3[rt&lt;&lt;1]+tree3[rt&lt;&lt;1|1]+tree2[rt&lt;&lt;1]+tree2[rt&lt;&lt;1|1]+tree[rt&lt;&lt;1]+tree[rt&lt;&lt;1|1];//该区间flag为2，因为没有下推，所以左右子树可能会有flag=1、2、3的，然后加上该区间的flag的值2，肯定会大于等于3。。。 tree2[rt]=x[r+1]-x[l]-tree3[rt]; tree[rt]=0; &#125; else if (flag[rt]==1) &#123; tree3[rt]=(l==r)?0:tree3[rt&lt;&lt;1]+tree3[rt&lt;&lt;1|1]+tree2[rt&lt;&lt;1]+tree2[rt&lt;&lt;1|1];//同理只有子树flag=2、3，然后加上父亲的flag的值1才会大于等于3 tree2[rt]=(l==r)?0:tree[rt&lt;&lt;1]+tree[rt&lt;&lt;1|1];//同理子树flag=1加上父亲的flag的值1才会大于等于2 tree[rt]=x[r+1]-x[l]-tree3[rt]-tree2[rt]; &#125; else if (l==r) tree[rt]=tree2[rt]=tree3[rt]=0;//因为上三种情况都没有那肯定是当前没有覆盖，面积肯定是0呀，且没子树了，所以单独列出来 else &#123; tree[rt]=tree[rt&lt;&lt;1]+tree[rt&lt;&lt;1|1]; tree2[rt]=tree2[rt&lt;&lt;1]+tree2[rt&lt;&lt;1|1]; tree3[rt]=tree3[rt&lt;&lt;1]+tree3[rt&lt;&lt;1|1]; &#125;&#125;void updata(int nl,int nr,int nc,int l,int r,int rt)&#123; if (nl&lt;=l&amp;&amp;r&lt;=nr) &#123; flag[rt]+=nc; pushup(l,r,rt);//注意这里要写这个，比较特殊。因为子树可能可以通过父树的标记加上自己子树的标记满足题目条件 return; &#125; int m=(l+r)&gt;&gt;1; if (nl&lt;=m) updata(nl,nr,nc,l,m,rt&lt;&lt;1); if (nr&gt;m) updata(nl,nr,nc,m+1,r,rt&lt;&lt;1|1); pushup(l,r,rt);//不用担心有节点离父树好几层，无法加到，导致少加了一些。因为每次pushup上来可以保证某一层以上的都是正确的，然后如果需要updata更深层的，虽然最深层到那某一层的路途中可能都是错误的，但是可以保证的是，继续向上pushup上来，某一层包括自己及以上的都是正确的，所以往最坏的情况想至少可以保证tree[1],tree2[1],tree3[1]是正确的。&#125;int main()&#123; int n,t,cnt,real_cnt,cas=0,cont,real_cont; int x1,y1,z1,x2,y2,z2; long long ans; scanf("%d",&amp;t); while (t--) &#123; ans=0; cont=0; scanf("%d",&amp;n); for (int i=1;i&lt;=n;i++) &#123; scanf("%d%d%d%d%d%d",&amp;sx[i].x,&amp;sx[i].y,&amp;sx[i].z,&amp;sx[i+n].x,&amp;sx[i+n].y,&amp;sx[i+n].z); sx[i].x+=fuck; sx[i].y+=fuck; sx[i+n].x+=fuck; sx[i+n].y+=fuck; ak[++cont]=sx[i].z; ak[++cont]=sx[i+n].z;//离散z轴 &#125; sort(ak+1,ak+cont+1); real_cont=unique(ak+1,ak+cont+1)-ak-1; for (int k=1;k&lt;real_cont;k++)//枚举z轴，相当于切黄瓜一样，一层一层算，而且z都是整数,这里用k防止和sx的z混淆 &#123; cnt=0; for (int i=1;i&lt;=n;i++) &#123; if (sx[i].z&lt;=ak[k]&amp;&amp;ak[k]&lt;sx[i+n].z)//排除像这种1 1 1 2 2 2 / 1 1 1 8 8 8 错算成2的情况 &#123; x[++cnt]=sx[i].x; line[cnt]=Node(sx[i].x,sx[i+n].x,sx[i].y,1); x[++cnt]=sx[i+n].x; line[cnt]=Node(sx[i].x,sx[i+n].x,sx[i+n].y,-1); &#125; &#125; if (cnt&lt;=2) continue;//剪枝并且控制重叠次数语句 sort(x+1,x+cnt+1); real_cnt=unique(x+1,x+cnt+1)-x-1; sort(line+1,line+cnt+1,cmp); /*for (int i=1;i&lt;=real_cnt;i++) &#123; cz[x[i]]=i; &#125;*/ for (int i=(cnt&lt;&lt;2|3);i&gt;=1;i--) &#123; flag[i]=tree[i]=tree2[i]=tree3[i]=0; &#125; for (int i=1;i&lt;cnt;i++) &#123; int l=lower_bound(x+1,x+real_cnt+1,line[i].l)-x; int r=lower_bound(x+1,x+real_cnt+1,line[i].r)-x; updata(l,r-1,line[i].cov,1,real_cnt,1);//下面的-1是为了弥补比如原来(3,3)的空档，注意-1位置，和我之前的习惯不一样，虽然也可以用我那种。。。 ans+=1ll*tree3[1]*(line[i+1].h-line[i].h)*(ak[k+1]-ak[k]);//乘上这个，因为如果z轴是一个是2一个是4，那3肯定是连续体积的，2~4不会是不连续的 &#125; &#125; printf("Case %d: %lld\n",++cas,ans); &#125;&#125; 两种版本时间区别这么大的原因（仅代表个人观点）：第一种因为保证了每个区间都是正确的，可能updata时前半部分的区间范围条件已经满足，但总是标记混乱，直到最后l==r时，这就导致了效率极其低下，因为此题不需要每个区间都正确，只需要下标为1的第一个区间即可。然后第二种就是只保证了下标为1的区间的正确性，不保证下面的正确与否，updata一到满足的区间就立马updata了，效率就快很多了。。。]]></content>
      <categories>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>区间合并</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World!]]></title>
    <url>%2Fblog%2Fposts%2F1c291ca3%2F</url>
    <content type="text"><![CDATA[欢迎来到我的Blog！ 第一次用Markdown+hexo+github写博文有点小紧张，不知道怎么写，突然不知道写什么了。。那就先写一些折腾hexo的东西吧。。。（首行缩进，讲究！） 1. 关于hexo浏览页面如何只显示部分想要的文字&lt;!-- more --&gt; 其实只需要在你想显示的文字末尾写上这句话就好了，这是Markdown语法，Markdown遇到这个会自动截断 2. Markdown在线编译器推荐 Cmd Markdown Cmd Markdown 简明语法手册 3. 使用hexo+github搭建直接推荐2个网址，我觉得写得很好，很详细，也谢谢这2位博主把我拉出了这个搭建的坑。。。 使用Hexo+Github一步步搭建属于自己的博客（基础） 使用github子目录部署hexo个人博客 需要注意的是，如果安装了github客户端，其实是可以跳过用git bush连接hexo和github的操作的，每次都用github客户端提交就好了。然后如果提交上去页面无法生成的话，是可以在你github的项目的setting下的Github Pages上看到错误的原因的。我遇到的问题是因为默认的landscape主题有一行代码有点小问题，导致无法生成页面。。。 暂且就写那么多了，这个博客还是以记录我的ACM之路为主吧。。。]]></content>
      <categories>
        <category>我的随笔</category>
      </categories>
  </entry>
</search>
